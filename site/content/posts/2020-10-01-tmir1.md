+++
title = "This Month in Rune"
date = 2020-10-01
draft = true
template = "post.html"

[taxonomies]
categories = ["TMIR"]
tags = ["updates"]

[extra]
author = "John-John Tedro"
+++

Less then one month ago [I announced Rune on
Reddit](https://www.reddit.com/r/rust/comments/in67d3/introducing_rune_a_new_stackbased_dynamic/).
And the response has been amazing.

In this post I'll detail the developments that have happened in the Language
since its initial announcement.

<!-- more -->



## Macros

We taught Rune how to parse and execute macros. Macros are procedures which
takes one token stream, and produces another one which is added to the code at
compile time. Like procedural macros in Rust.

In Rune they are currently *experimental*. They can only be defined as part of a
native module and needs a compiler option to enable.

Rune parsing has been designed in a way so that it can be used in macros,
similarly to what you get through the `syn` crate. We also provide a `quote!`
Rust macro to perform quasi-quoting.

The following is an example macro that comes with the `std::experiments` crate,
that performs "stringy math":

```rust
use rune::ast;
use rune::Resolve as _;
use rune::{quote, MacroContext, Parser, Spanned, TokenStream};

/// Implementation for the `stringy_math!` macro.
pub(crate) fn stringy_math(
    ctx: &mut MacroContext,
    stream: &TokenStream,
) -> runestick::Result<TokenStream> {
    let mut parser = Parser::from_token_stream(stream);

    let mut output = quote!(ctx => 0);

    while !parser.is_eof()? {
        let op = parser.parse::<ast::Ident>()?;
        let arg = parser.parse::<ast::Expr>()?;

        output = match op.macro_resolve(ctx)?.as_ref() {
            "add" => quote!(ctx => (#output) + #arg),
            "sub" => quote!(ctx => (#output) - #arg),
            "div" => quote!(ctx => (#output) / #arg),
            "mul" => quote!(ctx => (#output) * #arg),
            _ => {
                return Err(From::from(runestick::SpannedError::msg(
                    op.span(),
                    "unsupported operation",
                )));
            }
        }
    }

    parser.parse_eof()?;
    Ok(output)
}
```

You can see it in action here:

{% rune(footnote = "Use of the stringy_math! macro", options = "macros=true", experimental = true) %}
use std::experiments::stringy_math;

fn main() {
    let value = stringy_math!(add 10 sub 5);
    println(`result: {value}`);
}
{% end %}

## `const` evaluation

Work has been started to support *`const` evaluation*. Constant evaluation
similarly to macros perform work at compile time, to produce values which are
literals embedded in the compiled code.

{% rune(footnote = "Asynchronous programming using select", manually = true) %}
const fn greeting(name) {
    `Hello {name}`
}

const GREETINGS = [
    greeting("Stranger"),
    greeting("Jane"),
    greeting("John"),
    greeting("Mio"),
];

fn main() {
    let rng = rand::WyRand::new();
    let greetings = GREETINGS;

	println(greetings[rng.int_range(0, greetings.len())]);
}
{% end %}

Usually all work is compiled at runtime through the bytecode-based virtual
machine, but constant evaluation introduces a subset of the language which can
be run and evaluated at compile time.

This currently includes:
* Numerical computations (for floats and numbers).
* Simple control flow through `if`, `while`, and `loop`.
* A number of binary operators.
* String templates.
* ... and more

As a bonus, here's the fibonacci default example, as a constant function:

{% rune(footnote = "Asynchronous programming using select", manually = true) %}
const fn fib(n) {
    if n <= 1 {
        n
    } else {
        fib(n - 1) + fib(n - 2)
    }
}

fn main() {
    fib(15)
}
{% end %}
